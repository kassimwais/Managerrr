{"ast":null,"code":"var _s = $RefreshSig$();\n\n//Firestore DB Object\nimport { useReducer, useEffect, useState } from \"react\";\nimport { db, timestamp } from \"../firebase/config\"; //When firestore sends back a response after we make a add document request, then that response also contains the added document\n//We keep all this state in one object because all of this state is related to each other. So that is why we use useReducer to manage this complex related state. \n\nlet initialState = {\n  document: null,\n  isPending: false,\n  error: null,\n  isSuccess: false\n}; //Reducer function\n\nconst fireStoreReducer = (state, action) => {\n  switch (action.type) {\n    case 'IS_PENDING':\n      return {\n        isPending: true,\n        document: null,\n        error: null,\n        isSuccess: false\n      };\n\n    case 'DOCUMENT_ADDED':\n      return {\n        isPending: false,\n        document: action.payload,\n        isSuccess: true,\n        error: null\n      };\n\n    case 'DOCUMENT_DELETED':\n      return {\n        isPending: false,\n        document: null,\n        isSuccess: true,\n        error: null\n      };\n\n    case 'DOCUMENT_UPDATED':\n      return {\n        isPending: false,\n        document: action.payload,\n        isSuccess: true,\n        error: null\n      };\n\n    case 'ERROR':\n      return {\n        error: action.payload,\n        isPending: false,\n        document: null,\n        isSuccess: false\n      };\n\n    default:\n      return state;\n  }\n}; //We accept a collection here so that we can use this hook in other projects too. That's why collection is not hardcoded here\n\n\nexport const useFirestore = collectionName => {\n  _s();\n\n  const [response, dispatch] = useReducer(fireStoreReducer, initialState); //To handle cleanup\n\n  const [isUnmounted, setIsUnmounted] = useState(false); //Reference to the collection via the collectionName passed to this hook\n\n  const collectionReference = db.collection(collectionName); //Only dispatch if not Unmounted\n\n  const dispatchIfNotUnmounted = action => {\n    if (!isUnmounted) {\n      dispatch(action);\n    }\n  }; //Add new Document\n\n\n  const addDocument = async document => {\n    dispatch({\n      type: 'IS_PENDING'\n    });\n\n    try {\n      const createdAt = timestamp.fromDate(new Date());\n      document = { ...document,\n        createdAt\n      };\n      const response = await collectionReference.add(document);\n      dispatchIfNotUnmounted({\n        type: 'DOCUMENT_ADDED',\n        payload: response\n      });\n    } catch (error) {\n      dispatchIfNotUnmounted({\n        type: 'ERROR',\n        payload: error.message\n      });\n    }\n  }; //Delete a Document\n\n\n  const deleteDocument = async documentId => {\n    dispatch({\n      type: 'IS_PENDING'\n    });\n\n    try {\n      await collectionReference.doc(documentId).delete();\n      dispatchIfNotUnmounted({\n        type: 'DOCUMENT_DELETED'\n      });\n    } catch (error) {\n      dispatchIfNotUnmounted({\n        type: 'ERROR',\n        payload: \"Could not Delete!\"\n      });\n    }\n  }; //Update a Document\n\n\n  const updateDocument = async (documentId, data) => {\n    dispatch({\n      type: 'IS_PENDING'\n    });\n\n    try {\n      const response = await collectionReference.doc(documentId).update(data);\n      dispatchIfNotUnmounted({\n        type: 'DOCUMENT_UPDATED',\n        payload: response\n      });\n    } catch (error) {\n      dispatchIfNotUnmounted({\n        type: 'ERROR',\n        payload: \"Could not Update!\"\n      });\n    }\n  };\n\n  useEffect(() => {\n    return () => {\n      setIsUnmounted(true);\n    };\n  }, []);\n  return {\n    response,\n    addDocument,\n    deleteDocument,\n    updateDocument\n  };\n};\n\n_s(useFirestore, \"dTvZEXoNPNxgmUbHGVnoZDCLyCk=\");","map":{"version":3,"sources":["/Users/owner/Documents/PM-Source/src/hooks/useFirestore.js"],"names":["useReducer","useEffect","useState","db","timestamp","initialState","document","isPending","error","isSuccess","fireStoreReducer","state","action","type","payload","useFirestore","collectionName","response","dispatch","isUnmounted","setIsUnmounted","collectionReference","collection","dispatchIfNotUnmounted","addDocument","createdAt","fromDate","Date","add","message","deleteDocument","documentId","doc","delete","updateDocument","data","update"],"mappings":";;AAAA;AACA,SAASA,UAAT,EAAqBC,SAArB,EAAgCC,QAAhC,QAAgD,OAAhD;AACA,SAASC,EAAT,EAAcC,SAAd,QAA8B,oBAA9B,C,CAGA;AAEA;;AACA,IAAIC,YAAY,GAAG;AACfC,EAAAA,QAAQ,EAAE,IADK;AAEfC,EAAAA,SAAS,EAAE,KAFI;AAGfC,EAAAA,KAAK,EAAE,IAHQ;AAIfC,EAAAA,SAAS,EAAE;AAJI,CAAnB,C,CAQA;;AACA,MAAMC,gBAAgB,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACxC,UAAOA,MAAM,CAACC,IAAd;AACI,SAAK,YAAL;AACI,aAAO;AACHN,QAAAA,SAAS,EAAE,IADR;AAEHD,QAAAA,QAAQ,EAAE,IAFP;AAGHE,QAAAA,KAAK,EAAE,IAHJ;AAIHC,QAAAA,SAAS,EAAE;AAJR,OAAP;;AAMJ,SAAK,gBAAL;AACI,aAAO;AACHF,QAAAA,SAAS,EAAE,KADR;AAEHD,QAAAA,QAAQ,EAAEM,MAAM,CAACE,OAFd;AAGHL,QAAAA,SAAS,EAAE,IAHR;AAIHD,QAAAA,KAAK,EAAE;AAJJ,OAAP;;AAMJ,SAAK,kBAAL;AACQ,aAAO;AACHD,QAAAA,SAAS,EAAE,KADR;AAEHD,QAAAA,QAAQ,EAAE,IAFP;AAGHG,QAAAA,SAAS,EAAE,IAHR;AAIHD,QAAAA,KAAK,EAAE;AAJJ,OAAP;;AAMR,SAAK,kBAAL;AACI,aAAO;AACHD,QAAAA,SAAS,EAAE,KADR;AAEHD,QAAAA,QAAQ,EAAEM,MAAM,CAACE,OAFd;AAGHL,QAAAA,SAAS,EAAE,IAHR;AAIHD,QAAAA,KAAK,EAAE;AAJJ,OAAP;;AAMJ,SAAK,OAAL;AACI,aAAO;AACHA,QAAAA,KAAK,EAAEI,MAAM,CAACE,OADX;AAEHP,QAAAA,SAAS,EAAE,KAFR;AAGHD,QAAAA,QAAQ,EAAE,IAHP;AAIHG,QAAAA,SAAS,EACT;AALG,OAAP;;AAOJ;AACI,aAAOE,KAAP;AAtCR;AAwCH,CAzCD,C,CA4CA;;;AAEA,OAAO,MAAMI,YAAY,GAAIC,cAAD,IAAoB;AAAA;;AAE5C,QAAM,CAACC,QAAD,EAAWC,QAAX,IAAuBlB,UAAU,CAACU,gBAAD,EAAmBL,YAAnB,CAAvC,CAF4C,CAI5C;;AACA,QAAM,CAACc,WAAD,EAAcC,cAAd,IAAgClB,QAAQ,CAAC,KAAD,CAA9C,CAL4C,CAO5C;;AACA,QAAMmB,mBAAmB,GAAGlB,EAAE,CAACmB,UAAH,CAAcN,cAAd,CAA5B,CAR4C,CAU5C;;AACA,QAAMO,sBAAsB,GAAIX,MAAD,IAAY;AACvC,QAAG,CAACO,WAAJ,EAAgB;AACZD,MAAAA,QAAQ,CAACN,MAAD,CAAR;AACH;AACJ,GAJD,CAX4C,CAiB5C;;;AACC,QAAMY,WAAW,GAAG,MAAOlB,QAAP,IAAoB;AACrCY,IAAAA,QAAQ,CAAC;AAACL,MAAAA,IAAI,EAAE;AAAP,KAAD,CAAR;;AACA,QAAI;AAEA,YAAMY,SAAS,GAAGrB,SAAS,CAACsB,QAAV,CAAmB,IAAIC,IAAJ,EAAnB,CAAlB;AACArB,MAAAA,QAAQ,GAAG,EAAC,GAAGA,QAAJ;AAAcmB,QAAAA;AAAd,OAAX;AACA,YAAMR,QAAQ,GAAG,MAAMI,mBAAmB,CAACO,GAApB,CAAwBtB,QAAxB,CAAvB;AAEAiB,MAAAA,sBAAsB,CAAC;AAACV,QAAAA,IAAI,EAAE,gBAAP;AAAyBC,QAAAA,OAAO,EAAEG;AAAlC,OAAD,CAAtB;AAEH,KARD,CAQE,OAAMT,KAAN,EAAY;AACVe,MAAAA,sBAAsB,CAAC;AAACV,QAAAA,IAAI,EAAE,OAAP;AAAgBC,QAAAA,OAAO,EAAEN,KAAK,CAACqB;AAA/B,OAAD,CAAtB;AACH;AACH,GAbD,CAlB2C,CAiC3C;;;AACA,QAAMC,cAAc,GAAG,MAAOC,UAAP,IAAsB;AAC1Cb,IAAAA,QAAQ,CAAC;AAACL,MAAAA,IAAI,EAAE;AAAP,KAAD,CAAR;;AAEA,QAAI;AACA,YAAMQ,mBAAmB,CAACW,GAApB,CAAwBD,UAAxB,EAAoCE,MAApC,EAAN;AACAV,MAAAA,sBAAsB,CAAC;AAACV,QAAAA,IAAI,EAAE;AAAP,OAAD,CAAtB;AACH,KAHD,CAGE,OAAML,KAAN,EAAY;AACVe,MAAAA,sBAAsB,CAAC;AAACV,QAAAA,IAAI,EAAE,OAAP;AAAgBC,QAAAA,OAAO,EAAE;AAAzB,OAAD,CAAtB;AACH;AACJ,GATA,CAlC2C,CA6C5C;;;AACC,QAAMoB,cAAc,GAAG,OAAOH,UAAP,EAAmBI,IAAnB,KAA4B;AAChDjB,IAAAA,QAAQ,CAAC;AAACL,MAAAA,IAAI,EAAE;AAAP,KAAD,CAAR;;AACA,QAAI;AACA,YAAMI,QAAQ,GAAG,MAAMI,mBAAmB,CAACW,GAApB,CAAwBD,UAAxB,EAAoCK,MAApC,CAA2CD,IAA3C,CAAvB;AACAZ,MAAAA,sBAAsB,CAAC;AAACV,QAAAA,IAAI,EAAE,kBAAP;AAA2BC,QAAAA,OAAO,EAAEG;AAApC,OAAD,CAAtB;AACH,KAHD,CAGE,OAAMT,KAAN,EAAY;AACVe,MAAAA,sBAAsB,CAAC;AAACV,QAAAA,IAAI,EAAE,OAAP;AAAgBC,QAAAA,OAAO,EAAE;AAAzB,OAAD,CAAtB;AACH;AACJ,GARA;;AAUAb,EAAAA,SAAS,CAAC,MAAM;AACZ,WAAO,MAAM;AACTmB,MAAAA,cAAc,CAAC,IAAD,CAAd;AACH,KAFD;AAGH,GAJQ,EAIP,EAJO,CAAT;AAMA,SAAO;AAACH,IAAAA,QAAD;AAAWO,IAAAA,WAAX;AAAwBM,IAAAA,cAAxB;AAAwCI,IAAAA;AAAxC,GAAP;AACJ,CA/DM;;GAAMnB,Y","sourcesContent":["//Firestore DB Object\nimport { useReducer, useEffect, useState } from \"react\";\nimport { db , timestamp} from \"../firebase/config\";\n\n\n//When firestore sends back a response after we make a add document request, then that response also contains the added document\n\n//We keep all this state in one object because all of this state is related to each other. So that is why we use useReducer to manage this complex related state. \nlet initialState = {\n    document: null,\n    isPending: false,\n    error: null,\n    isSuccess: false\n}\n\n\n//Reducer function\nconst fireStoreReducer = (state, action) => {\n    switch(action.type){\n        case 'IS_PENDING':\n            return {\n                isPending: true, \n                document: null, \n                error: null,\n                isSuccess: false\n            }\n        case 'DOCUMENT_ADDED':\n            return {\n                isPending: false, \n                document: action.payload, \n                isSuccess: true, \n                error: null\n            }\n        case 'DOCUMENT_DELETED':\n                return {\n                    isPending: false, \n                    document: null, \n                    isSuccess: true, \n                    error: null\n            }\n        case 'DOCUMENT_UPDATED':\n            return {\n                isPending: false, \n                document: action.payload, \n                isSuccess: true, \n                error: null\n        }\n        case 'ERROR':\n            return {\n                error: action.payload, \n                isPending: false, \n                document: null, \n                isSuccess: \n                false \n            }\n        default:\n            return state\n    }\n}\n\n\n//We accept a collection here so that we can use this hook in other projects too. That's why collection is not hardcoded here\n\nexport const useFirestore = (collectionName) => {\n     \n    const [response, dispatch] = useReducer(fireStoreReducer, initialState);\n\n    //To handle cleanup\n    const [isUnmounted, setIsUnmounted] = useState(false);\n\n    //Reference to the collection via the collectionName passed to this hook\n    const collectionReference = db.collection(collectionName);\n\n    //Only dispatch if not Unmounted\n    const dispatchIfNotUnmounted = (action) => {\n        if(!isUnmounted){\n            dispatch(action);\n        }\n    }\n\n    //Add new Document\n     const addDocument = async (document) => {\n        dispatch({type: 'IS_PENDING'});\n        try {\n\n            const createdAt = timestamp.fromDate(new Date());\n            document = {...document, createdAt}\n            const response = await collectionReference.add(document);\n\n            dispatchIfNotUnmounted({type: 'DOCUMENT_ADDED', payload: response})\n            \n        } catch(error){\n            dispatchIfNotUnmounted({type: 'ERROR', payload: error.message})\n        }\n     }\n\n     //Delete a Document\n     const deleteDocument = async (documentId) => {\n        dispatch({type: 'IS_PENDING'});\n\n        try {\n            await collectionReference.doc(documentId).delete();\n            dispatchIfNotUnmounted({type: 'DOCUMENT_DELETED'})\n        } catch(error){\n            dispatchIfNotUnmounted({type: 'ERROR', payload: \"Could not Delete!\"})\n        }\n    }\n\n    //Update a Document\n     const updateDocument = async (documentId, data) => {\n        dispatch({type: 'IS_PENDING'});\n        try {\n            const response = await collectionReference.doc(documentId).update(data);\n            dispatchIfNotUnmounted({type: 'DOCUMENT_UPDATED', payload: response})\n        } catch(error){\n            dispatchIfNotUnmounted({type: 'ERROR', payload: \"Could not Update!\"})\n        }\n    }\n\n     useEffect(() => {\n         return () => {\n             setIsUnmounted(true);\n         }\n     },[])\n\n     return {response, addDocument, deleteDocument, updateDocument}\n}\n"]},"metadata":{},"sourceType":"module"}